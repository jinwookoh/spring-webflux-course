안녕하세요\! R2DBC 프로젝트 설정 강의에 대한 전문적인 요약을 제공해 드리겠습니다.

### 프롬프트 1: 핵심 요약

이번 강의는 Spring WebFlux와 R2DBC를 사용하여 반응형 애플리케이션 개발 환경을 설정하는 방법을 다룹니다. **무엇**을 하는지에 초점을 맞추면, **고객(Customer), 제품(Product), 고객 주문(Customer\_Order)이라는 세 개의 연관된 데이터베이스 테이블을 생성**합니다. 이 테이블들은 `data.sql` 스크립트를 통해 스키마가 정의되고 초기 데이터가 채워집니다. **왜** 이렇게 하는지에 대한 이유는 두 가지입니다. 첫째, 애플리케이션이 시작될 때 즉시 사용할 수 있는 테스트 데이터를 확보하기 위함입니다. 둘째, 매번 동일한 환경에서 통합 테스트를 실행할 수 있도록, 테스트 시작 전에 기존 테이블을 삭제하고 새로 만드는 과정을 포함하여 **일관성 있고 반복 가능한 테스트 환경을 구축**하기 위함입니다. 또한, 프로젝트가 여러 섹션으로 나뉨에 따라 발생할 수 있는 Spring Bean 충돌 문제를 방지하기 위해 `scanBasePackages` 속성을 사용하여 특정 패키지만 스캔하도록 설정합니다. 이는 프로젝트가 커져도 각 기능 단위가 독립적으로 관리될 수 있도록 하는 중요한 구성 작업입니다.

-----

### 프롬프트 2: 핵심 정리

  * **일관된 테스트 환경을 위해 `data.sql` 파일 상단에 `DROP TABLE` 문을 포함시켜 각 테스트 실행 전에 데이터베이스를 초기화하세요.** 이는 테스트가 이전 상태에 영향을 받지 않고 독립적으로 실행되도록 보장합니다.
  * **고객, 제품, 그리고 이 둘을 연결하는 고객 주문 테이블을 설계하여 데이터 관계를 명확히 정의하세요.** 고객 주문 테이블에는 `customer_id`와 `product_id`를 외래 키(Foreign Key)로 포함시켜 각 주문이 어떤 고객과 제품에 연결되는지 나타냅니다.
  * **애플리케이션 시작 시 필요한 기본 데이터를 `INSERT` 문을 사용하여 `data.sql`에 미리 추가해두세요.** 이를 통해 개발 및 테스트 단계에서 즉시 사용할 수 있는 샘플 데이터를 확보할 수 있습니다.
  * **대규모 프로젝트에서는 `@SpringBootApplication`의 `scanBasePackages` 속성을 사용하여 Bean 스캔 범위를 특정 패키지로 제한하세요.** 이렇게 하면 다른 섹션(패키지)에 동일한 이름의 컴포넌트가 있어도 Bean 충돌이 발생하는 것을 방지할 수 있습니다.
  * **R2DBC 리포지토리 역시 스캔할 기본 패키지를 지정하여 애플리케이션의 다른 부분과 격리되도록 설정하세요.** 이는 일반적인 컴포넌트 스캔과 별도로 리포지토리에 대한 설정을 맞추는 과정입니다.
  * **`application.properties` 파일에 `spring.sql.init.data-locations` 속성을 설정하여 Spring Boot가 `data.sql` 파일의 위치를 명시적으로 찾도록 지정하세요.** 이는 `resources`의 하위 디렉터리에 SQL 파일을 둘 때 필수적인 설정입니다.

-----

### 프롬프트 3: Q\&A 생성

1.  **Q: 왜 SQL 스크립트의 시작 부분에서 `DROP TABLE` 문을 실행하나요?**

      * **A:** 통합 테스트를 여러 번 실행할 때 항상 동일한 초기 상태에서 시작하기 위함입니다. 만약 테이블을 삭제하지 않으면 이전 테스트에서 변경된 데이터가 다음 테스트에 영향을 줄 수 있습니다. 테이블을 삭제하고 다시 생성함으로써 매번 깨끗한 환경에서 테스트를 수행할 수 있습니다.

2.  **Q: `scanBasePackages` 속성을 사용하는 주된 이유는 무엇인가요?**

      * **A:** 프로젝트 내에 `section01`, `section02` 등 여러 패키지가 있고, 각 패키지에 `ProductRepository`처럼 이름이 같은 Bean이 있을 경우 Spring이 어떤 것을 등록해야 할지 몰라 오류를 발생시킵니다. `scanBasePackages`를 사용하면 Spring에게 "지금은 이 특정 패키지 안에 있는 Bean들만 스캔해서 생성해"라고 알려주어 충돌을 피할 수 있습니다.

3.  **Q: 고객 주문(Customer Order) 테이블은 어떤 역할을 하나요?**

      * **A:** 고객 주문 테이블은 고객 테이블과 제품 테이블을 연결하는 중간 다리 역할을 합니다. 이 테이블에는 어떤 고객(`customer_id`)이 어떤 제품(`product_id`)을 언제, 얼마나 주문했는지에 대한 정보가 저장됩니다. 이를 통해 '누가 무엇을 샀는지'의 관계를 기록할 수 있습니다.

4.  **Q: `data.sql` 파일을 `resources` 폴더 바로 아래가 아닌 `sql`이라는 하위 폴더에 두는 이유는 무엇인가요?**

      * **A:** 프로젝트의 구조를 더 깔끔하게 정리하기 위해서입니다. 나중에 다른 종류의 SQL 스크립트나 설정 파일이 추가될 수 있으므로, `sql`과 같은 목적에 맞는 디렉터리를 만들어 파일을 관리하는 것이 좋습니다.

5.  **Q: R2DBC 리포지토리를 위해 별도의 기본 패키지 스캔 설정이 필요한 이유는 무엇인가요?**

      * **A:** R2DBC 리포지토리는 Spring의 일반적인 컴포넌트 스캔과는 다른 메커니즘을 가질 수 있기 때문입니다. 따라서 Spring Boot 애플리케이션의 일반 Bean 스캔 범위를 제한했을 때, R2DBC 리포지토리 역시 동일한 패키지 범위 내에서 생성되도록 명시적으로 설정해 주어야 합니다.

-----

### 프롬프트 4: 코드 및 개념 추출

#### 1\. SQL 스키마 및 데이터 정의 (`data.sql`)

```sql
파일 참고
```

  * **목적:** 이 SQL 블록은 애플리케이션에 필요한 데이터베이스 테이블의 구조를 정의하고, 테스트 및 개발에 사용할 초기 데이터를 삽입하는 역할을 합니다.

#### 2\. Spring Boot 애플리케이션 설정 (Java)

```java
@SpringBootApplication(scanBasePackages = "com.vinsguru.playground.sec02")
public class WebfluxPlaygroundApplication {
    public static void main(String[] args) {
        SpringApplication.run(WebfluxPlaygroundApplication.class, args);
    }
}
```

  * **목적:** 이 코드는 Spring Boot 애플리케이션이 시작될 때 `com.vinsguru.playground.sec02` 패키지 내의 컴포넌트만 스캔하여 Bean으로 등록하도록 제한합니다.

#### 3\. 애플리케이션 속성 설정 (`application.properties`)

```properties
# 현재 활성화할 섹션 지정 (Java 코드에서 이 값을 사용하여 scanBasePackages 경로를 동적으로 구성할 수 있음)
section=02

# Spring에게 데이터베이스 초기화 스크립트의 위치를 알려줌
spring.sql.init.data-locations=classpath:sql/data.sql

# R2DBC 리포지토리 스캔을 위한 기본 패키지 지정 (강의 내용에 따라 추정)
spring.data.r2dbc.repositories.base-packages=com.vinsguru.playground.sec02
```

  * **목적:** 이 속성 파일은 Spring Boot에게 데이터베이스 초기화에 사용할 SQL 파일의 위치를 알려주고, 특정 패키지만 스캔하도록 애플리케이션 동작을 제어합니다.
